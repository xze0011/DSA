# 0/1 Knapsack

二维
```java
class Solution {
    /**
     * @param totalItems number of items
     * @param capacity capacity
     * @param space space[i] = weight/volume of item i
     * @param value value[i] = value of item i
     * @return maximum total value under capacity (0/1 knapsack)
     */
    public int maxValue(int totalItems, int capacity, int[] space, int[] value) {
        int len = space.length;
        int items = Math.min(totalItems, len);

        // dp[i][j]: using first i items, max value with capacity j
        int[][] dp = new int[items + 1][capacity + 1];

        // dp[0][*] = 0, dp[*][0] = 0 （Java 默认初始化为 0）

        for (int i = 1; i <= items; i++) {
            int currentValueWeight = space[i - 1]; // 当前物品重量
            int currentItemValue = value[i - 1];  // 当前物品价值

            for (int j = 1; j <= capacity; j++) {

                // 情况 1：不选当前物品
                int dontHaveI = dp[i - 1][j];

                // 如果容量不够，不能选当前物品, 只能选择情况 1
                if (currentValueWeight > j) {
                    dp[i][j] = dontHaveI;
                } else {

                     // 情况 2：选当前物品
                int haveI = dp[i - 1][j - currentValueWeight] + currentItemValue;

                    // Max(情况 1, 情况 2)
                    dp[i][j] = Math.max(haveI, dontHaveI);
                }
            }
        }

        return dp[items][capacity];
    }
}
```

一维
```java
class Solution {
    public int maxValue(int totalItems, int capacity, int[] space, int[] value) {
        int len = space.length;
        int items = Math.min(totalItems, len);

        // dp[c]: max value with capacity c
        int[] dp = new int[capacity + 1];

        for (int i = 1; i <= items; i++) {
            int currentValueWeight = space[i - 1];
            int currentItemValue = value[i - 1];

            // 关键：容量倒序，保证每个物品只用一次
            for (int j = capacity; j >= currentValueWeight; j--) {
                dp[j] = Math.max(
                    dp[j],
                    dp[j - currentValueWeight] + currentItemValue
                );
            }
        }

        return dp[capacity];
    }
}
```