# 685. Redundant Connection II

```java
class Solution {
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int n = edges.length;

        // 1️⃣ 记录每个节点的父节点（用于判断入度）
        int[] indegreeParent = new int[n + 1];

        // 两条候选边（当某个节点入度为 2 时）
        int[] cand1 = null; // 旧父 -> v
        int[] cand2 = null; // 新父 -> v

        // 2️⃣ 第一次扫描：找入度为 2 的节点
        for (int[] e : edges) {
            int u = e[0];
            int v = e[1];

            if (indegreeParent[v] != 0) {
                // v 已经有父节点了
                cand1 = new int[]{indegreeParent[v], v};
                cand2 = new int[]{u, v};
            } else {
                indegreeParent[v] = u;
            }
        }

        // 3️⃣ 并查集，用来判断成环
        UnionFind uf = new UnionFind(n + 1);

        // 4️⃣ 第二次扫描：判断成环
        for (int[] e : edges) {
            // 如果存在入度为 2，先“假装删除 cand2”
            if (cand2 != null && e[0] == cand2[0] && e[1] == cand2[1]) {
                continue;
            }

            int u = e[0];
            int v = e[1];

            // 如果 union 前已经连通，说明成环
            if (uf.find(u) == uf.find(v)) {
                // 情况一：没有入度为 2，纯环
                if (cand1 == null) {
                    return e;
                }
                // 情况三：有入度为 2 + 成环
                return cand1;
            }

            uf.union(u, v);
        }

        // 5️⃣ 情况二：有入度为 2，但删 cand2 后不成环
        return cand2;
    }
}

class UnionFind {
    int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int a, int b) {
        int pa = find(a);
        int pb = find(b);
        if (pa != pb) {
            parent[pa] = pb;
        }
    }
}
```
